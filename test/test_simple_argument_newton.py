"""
TODO
"""

from datetime import timedelta

import numpy as np
import pytest
from hypothesis import given, settings, strategies
from numpy.polynomial import Polynomial

from pyzeal import RootFinder
from pyzeal_logging.log_levels import LogLevel
from pyzeal_types.algorithm_types import AlgorithmTypes
from pyzeal_types.container_types import ContainerTypes
from pyzeal_types.filter_types import FilterTypes

from .testing_fixtures import simpleArgumentNewtonRootFinder
from .testing_resources import testFunctions
from .testing_utils import rootsMatchClosely

# set log level globally
LEVEL = LogLevel.DEBUG

KNOWN_FAILURES = [
    "log and sin composition",  # see issue #12
    "x^100",  # unusually high order root would require very high refinement,
    # which would take too long to compute for tests
    "1e6 * x^100",
]


@pytest.mark.parametrize("testName", testFunctions.keys())
@pytest.mark.parametrize("parallel", [False, True])
def testSimpleArgumentNewton(testName, parallel) -> None:
    if testName in KNOWN_FAILURES:
        assert True
        return
    expectedRoots = testFunctions[testName][
        2
    ]  # testFunctions contains values of the form (f, df, roots)
    hrf = simpleArgumentNewtonRootFinder(testName, LEVEL, parallel=parallel)
    hrf.calculateRoots((-5, 5), (-5, 5), precision=(5, 5))
    foundRoots = hrf.roots
    expectedRoots = np.sort_complex(np.array(expectedRoots))
    assert np.allclose(
        foundRoots, expectedRoots, atol=1e-3
    ) or rootsMatchClosely(foundRoots, expectedRoots, atol=1e-3)

@given(
    strategies.lists(
        strategies.complex_numbers(max_magnitude=10), min_size=1, max_size=10
    )
)
@settings(deadline=(timedelta(seconds=2)), max_examples=5)
def testSimpleArgumentNewtonHypothesis(roots) -> None:
    r"""
    Test the argument-principle-based root finder with data generated by the
    hypothesis package.
    """
    f = Polynomial.fromroots(roots)
    hrf = RootFinder(
        f,
        None,
        algorithmType=AlgorithmTypes.SIMPLE_ARGUMENT_NEWTON,
        containerType=ContainerTypes.ROUNDING_CONTAINER,
        verbose=False,
    )
    hrf.setLevel(level=LEVEL)
    hrf.setRootFilter(filterType=FilterTypes.FUNCTION_VALUE_ZERO)
    hrf.setRootFilter(filterType=FilterTypes.ZERO_IN_BOUNDS)
    hrf.calculateRoots((-5.0, 5.01), (-5.0, 5.01), precision=(5, 5))
    foundRoots = np.sort_complex(hrf.roots)

    # We only find a higher-order zero once, so we have to remove duplicates
    uniqueRoots = list(set(roots))
    expectedRoots = np.sort_complex(np.array(uniqueRoots))
    try:
        assert np.allclose(
            foundRoots, expectedRoots, atol=1e-3
        ) or rootsMatchClosely(foundRoots, expectedRoots, atol=1e-3)
    except ValueError:
        pass  # This happens if allclose is called with differing sizes
