"""
Tests of the grid-based Newton algorithm implementation.

Authors:\n
- Luca Wasmuth\n
"""

from datetime import timedelta

import numpy as np
import pytest
from hypothesis import given, settings, strategies
from numpy.polynomial import Polynomial

from pyzeal import RootFinder
from pyzeal_types.algorithm_types import AlgorithmTypes
from pyzeal_types.container_types import ContainerTypes
from pyzeal_types.filter_types import FilterTypes

from .testing_fixtures import newtonGridFinder
from .testing_resources import testFunctions
from .testing_utils import rootsMatchClosely

# 20 is enough to pass all tests while still running faster than the default 50
NUM_SAMPLE_POINTS = 20

KNOWN_FAILURES = ["x^4-1", "log and sin composition", "x^100", "1e6 * x^100"]


@pytest.mark.filterwarnings("ignore::RuntimeWarning")
@pytest.mark.parametrize("testName", testFunctions.keys())
@pytest.mark.parametrize("parallel", [False, True])
def testNewtonGridRootFinder(testName, parallel) -> None:
    "Test the Newton-Grid-Rootfinder with polynomial and elementary functions."
    if testName in KNOWN_FAILURES:
        assert True
        return
    expectedRoots = testFunctions[testName][
        2
    ]  # testFunctions contains values of the form (f, df, roots)
    for numSamplePoints in [20, 100]:
        gridRF = newtonGridFinder(testName, numSamplePoints, parallel=parallel)
        gridRF.calculateRoots((-5, 5), (-5, 5), precision=(4, 4))
        print(gridRF.roots)
        foundRoots = np.sort_complex(gridRF.roots)
        expectedRoots = np.sort_complex(np.array(expectedRoots))
        # First variant fails 1 test, second fails 3 tests - however, these
        # seem to be different ones:
        # assert np.allclose(foundRoots, expectedRoots, atol=1e-3)
        # assert rootsMatchClosely(foundRoots, expectedRoots, atol=1e-3)
        assert np.allclose(
            foundRoots, expectedRoots, atol=1e-3
        ) or rootsMatchClosely(foundRoots, expectedRoots, atol=1e-3)

@given(
    strategies.lists(
        strategies.complex_numbers(max_magnitude=10), min_size=1, max_size=10
    )
)
@settings(deadline=(timedelta(seconds=2)), max_examples=5)
def testNewtonGridRootFinderHypothesis(roots) -> None:
    """
    Test the Newton-Grid-Rootfinder with data generated by the hypothesis
    package.
    """
    f = Polynomial.fromroots(roots)
    df = f.deriv()
    gridRF = RootFinder(
        f,
        df=df,
        numSamplePoints=NUM_SAMPLE_POINTS,
        containerType=ContainerTypes.ROUNDING_CONTAINER,
        algorithmType=AlgorithmTypes.NEWTON_GRID,
    )
    gridRF.setRootFilter(filterType=FilterTypes.FUNCTION_VALUE_ZERO)
    gridRF.setRootFilter(filterType=FilterTypes.ZERO_IN_BOUNDS)
    gridRF.calculateRoots((-10, 10), (-10, 10), precision=(3, 3))
    foundRoots = np.sort_complex(gridRF.roots)
    # We only find a higher-order zero once, so we have to remove duplicates
    uniqueRoots = list(set(roots))
    expectedRoots = np.sort_complex(np.array(uniqueRoots))
    try:
        assert np.allclose(
            foundRoots, expectedRoots, atol=1e-3
        ) or rootsMatchClosely(foundRoots, expectedRoots, atol=1e-3)
    except ValueError:
        pass  # This happens if allclose is called with differing sizes
